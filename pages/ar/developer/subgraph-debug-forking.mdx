---
title: تصحيح أخطاء الـ subgraph بسرعة وسهولة باستخدام forks
---

> Note: this is only available from this `graph-node` [commit](https://github.com/graphprotocol/graph-node/commit/f4e6992d7949b18f990045c8babdcd205a060ef6) or this [docker tag](https://hub.docker.com/layers/graphprotocol/graph-node/f4e6992/images/sha256-51ad494a2ecc387bef2359d863b596ad5bd44436808964cf221e60365a7c00c8?context=explore) onwards, it hasn't been yet released in a minor release (eg: 0.26.0)

كما هو الحال مع العديد من الأنظمة التي تعالج كميات كبيرة من البيانات ، قد يستغرق مفهرسو The Graph أو (Graph nodes) بعض الوقت لمزامنة الـ subgraph الخاص بك مع blockchain الهدف. التناقض بين التغييرات السريعة بغرض تصحيح الأخطاء وأوقات الانتظار الطويلة اللازمة للفهرسة يؤدي إلى نتائج عكسية للغاية ونحن ندرك ذلك جيدًا. ولهذا السبب نقدم **subgraph forking ** ، الذي تم تطويره بواسطة [ LimeChain ](https://limechain.tech/) ، وفي هذه المقالة سنوضح لكم كيف يمكن استخدام هذه الميزة لتسريع تصحيح أخطاء الـ subgraph بشكل كبير!

## حسنا، ما هو؟

**Subgraph forking** هي عملية جلب الكيانات بشكل lazily من مخزن subgraph _آخر_ (عادةً ما يكون بعيدًا).

يسمح لك **subgraph forking** بتصحيح أخطاء الـ subgraph الفاشل في الكتلة(block) _ X _ دون الحاجة للانتظار للمزامنة للكتلة _ X _.

## ماذا؟! كيف؟

عندما تنشر subgraph إلى Graph node بعيدة للفهرسة ويفشل عند الكتلة _ X _ ، فإن الخبر الجيد هو أن Graph node ستظل تقدم استعلامات GraphQL باستخدام مخزنها(store)، والذي تمت مزامنته للكتلة(block) _ X _. هذا عظيم! هذا يعني أنه يمكننا الاستفادة من هذا المخزن "المحدث" لإصلاح الأخطاء التي تظهر عند فهرسة الكتلة _ X _.

In a nutshell, we are going to _fork the failing subgraph_ from a remote Graph node that is guaranteed to have the subgraph indexed up to block _X_ in order to provide the locally deployed subgraph being debugged at block _X_ an up-to-date view of the indexing state.

## من فضلك ، أرني بعض الأكواد!

للاستمرار في التركيز على تصحيح أخطاء الـ subgraph ، دعنا نجعل الأمور بسيطة ونعمل مع [example-subgraph](https://github.com/graphprotocol/example-subgraph) الذي يفهرس عقد Ethereum Gravity الذكي.

فيما يلي المعالجات (handlers) المعرفة لفهرسة `Gravatar` ، مع عدم وجود أخطاء على الإطلاق:

```tsx
export function handleNewGravatar(event: NewGravatar): void {
  let gravatar = new Gravatar(event.params.id.toHex().toString())
  gravatar.owner = event.params.owner
  gravatar.displayName = event.params.displayName
  gravatar.imageUrl = event.params.imageUrl
  gravatar.save()
}

export function handleUpdatedGravatar(event: UpdatedGravatar): void {
  let gravatar = Gravatar.load(event.params.id.toI32().toString())
  if (gravatar == null) {
    log.critical('Gravatar not found!', [])
    return
  }
  gravatar.owner = event.params.owner
  gravatar.displayName = event.params.displayName
  gravatar.imageUrl = event.params.imageUrl
  gravatar.save()
}
```

عفوًا ، يا للأسف ، عندما أنشر الـ subgraph الخاص بي ذو المظهر المثالي على [ HostedService ](https://thegraph.com/hosted-service/) ، فإنه يفشل مع ظهور الخطأ _ "Gravatar not found!" _.

الطريقة المعتادة لمحاولة الإصلاح هي:

1. إجراء تغيير في مصدر الـ mappings ، والذي تعتقد أنه سيحل المشكلة (وأنا أعلم أنه لن يحلها).
2. إعادة نشر الـ subgraph على [ HostedService ](https://thegraph.com/hosted-service/) (أو Graph node أخرى بعيدة).
3. الانتظار حتى تتم المزامنة.
4. إذا تعطل مرة أخرى ارجع إلى 1!

هذا مألوف لعملية تصحيح الأخطاء العادية ، ولكن هناك خطوة واحدة تؤدي إلى إبطاء العملية بشكل رهيب: _ 3. الانتظار حتى تتم المزامنة. _

باستخدام **subgraph forking** يمكننا التخلص من تلك الخطوة. إليك كيف يبدو:

0. قم بتنشيط Graph node محلية بمجموعة **_fork-base_** مناسبة.
1. قم بإجراء تغيير في مصدر الـ mappings ، والذي تعتقد أنه سيحل المشكلة.
2. Deploy to the local Graph node, **_forking the failing subgraph_** and **_starting from the problematic block_**.
3. إذا تعطل مرة أخرى ارجع إلى 1!

الآن ، قد يكون لديك سؤالان:

1. fork-base what??? 2) Forking who?!
2. Forking who?!

وأنا أجيب:

1. `fork-base` is the "base" URL, such that when the _subgraph id_ is appended the resulting URL (`<fork-base>/<subgraph-id>`) is a valid GraphQL endpoint for the subgraph's store. 2) Forking is easy, no need to sweat:
2. الـ Forking سهل ، لا داعي للقلق:

```bash
$ graph deploy <subgraph-name> --debug-fork <subgraph-id> --ipfs http://localhost:5001 --node http://localhost:8020
```

أيضًا ، لا تنس تعيين الحقل ` dataSources.source.startBlock ` في subgraph manifest لرقم الكتلة التي بها المشكلة، حتى تتمكن من تخطي فهرسة الكتل غير الضرورية والاستفادة من الـ fork!

لذلك ، هذا ما أفعله:

0. I spin-up a local graph node ([here is how to do it](https://github.com/graphprotocol/graph-node#running-a-local-graph-node)) with the `fork-base` option set to: `https://api.thegraph.com/subgraphs/id/`, since I will fork a subgraph, the buggy one I deployed earlier, from the [HostedService](https://thegraph.com/hosted-service/).

```
$ cargo run -p graph-node --release -- \
    --postgres-url postgresql://USERNAME[:PASSWORD]@localhost:5432/graph-node \
    --ethereum-rpc NETWORK_NAME:[CAPABILITIES]:URL \
    --ipfs 127.0.0.1:5001
    --fork-base https://api.thegraph.com/subgraphs/id/
```

1. After careful inspection I notice that there is a mismatch in the `id` representations used when indexing `Gravatar`s in my two handlers. While `handleNewGravatar` converts it to a hex (`event.params.id.toHex()`), `handleUpdatedGravatar` uses an int32 (`event.params.id.toI32()`) which causes the `handleUpdatedGravatar` to panic with "Gravatar not found!". I make them both convert the `id` to a hex.
2. After I made the changes I deploy my subgraph to the local Graph node, **_forking the failing subgraph_** and setting `dataSources.source.startBlock` to `6190343` in `subgraph.yaml`:

```bash
  $ graph deploy gravity --debug-fork QmNp169tKvomnH3cPXTfGg4ZEhAHA6kEq5oy1XDqAxqHmW --ipfs http://localhost:5001 --node http://localhost:8020
```

3. I inspect the logs produced by the local Graph node and, Hooray!, everything seems to be working.
4. I deploy my now bug-free subgraph to a remote Graph node and live happily ever after! (no potatoes tho)
5. The end...
